(* ****** ****** *)

#infixl 30 +
#infixl 30 -
#infixl 40 *
#infixl 20 >=
#infixr 10 ->

(* ****** ****** *)

val-
nil() = xs0
withtype list(int)

val+
:rec
x \cons xs2 = xs1

val
tup_flat = @(1, 2)
val
tup_boxd = $(1, 2)

(* ****** ****** *)

val
:rec
fact =
lam(x: int): int =<cloref1>
  if x >= 1 then x * fact(x-1) else 1
// end of [lam]

(* ****** ****** *)

fun<>
:(rec)
fact
{n:nat}.<n>.
(x: int(n)): int =
if x >= 1
  then fact(x-1, x*r) else 1
withtype (int, int) -> int

(* ****** ****** *)
////
(*
@tailrec
implement
foo(x) = bar(x)
@tailrec
implement
bar{..}(x) = foo(x)
*)

(* ****** ****** *)

(*
fun
prf
fact(x) = fact(x)
val prf fact = fact
val
rec
fact =
lam(x) =>
if x >= 1
  then x * fact(x-1) else 0
// end of [if]
withtype int -> int
*)

#static
fun
fact
{n:int}
.<n+1>.
(x: int(n)): intGte(1)

if:
[n:int]
(x:int(n), y:int(n)) =>
(x > 0)
then ...
else ...


while:
{n:int}
(x: int(n), y: int(n))
[n:int]
(x: int(n), y: int(n)) =>
(x > 10)
{
  val () = f(x)
  val () = f(x+y)
}


(* ****** ****** *)

(* end of [test_dynexp.dats] *)
