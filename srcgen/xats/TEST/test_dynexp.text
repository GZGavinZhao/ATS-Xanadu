implement
:nonrec
{a:type;b,c:tbox}
<a:type;b,c:tbox>
foo2<list(a)><b, c>(x: a): int = x

////
(* ****** ****** *)

#infixl 30 +
#infixl 30 -
#infixl 40 *
#infixl 20 >=
#infixr 10 ->

(* ****** ****** *)

abstype abc(a:int)<= int
abstype abc(a:int)== int
absimpl abc(a:int) = int
// absopen abc // explicit def

(* ****** ****** *)

fun
:rec
<a1,a2>
<b:type
;c:tbox>
foo(x: a):<ntm,wrt> @(b, c) = @(x, x)

(* ****** ****** *)

////

(* ****** ****** *)

val-
nil() = xs0
withtype list(int)

val+
:rec
x \cons xs2 = xs1

val
tup_flat = @(1, 2)
val
tup_boxd = $(1, 2)

(* ****** ****** *)

val
:rec
fact =
lam(x: int): int =<cloref1>
  if x >= 1 then x * fact(x-1) else 1
// end of [lam]

(* ****** ****** *)

#extern
fun
fact
{n:int}
(*.<n+1>.*)
(x: int(n)): intGte(1)

(* ****** ****** *)
////
(*
@tailrec
implement
foo(x) = bar(x)
@tailrec
implement
bar{..}(x) = foo(x)
*)

(* ****** ****** *)

(*
fun
prf
fact(x) = fact(x)
val prf fact = fact
val
rec
fact =
lam(x) =>
if x >= 1
  then x * fact(x-1) else 0
// end of [if]
withtype int -> int
*)

if:
[n:int]
(x:int(n), y:int(n)) =>
(x > 0)
then ...
else ...


while:
{n:int}
(x: int(n), y: int(n))
[n:int]
(x: int(n), y: int(n)) =>
(x > 10)
{
  val () = f(x)
  val () = f(x+y)
}


(* ****** ****** *)

(* end of [test_dynexp.dats] *)
